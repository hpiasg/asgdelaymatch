package de.uni_potsdam.hpi.asg.delaymatch;

/*
 * Copyright (C) 2016 Norman Kluge
 * 
 * This file is part of ASGdelaymatch.
 * 
 * ASGdelaymatch is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * ASGdelaymatch is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ASGdelaymatch.  If not, see <http://www.gnu.org/licenses/>.
 */

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.uni_potsdam.hpi.asg.common.io.FileHelper;
import de.uni_potsdam.hpi.asg.common.io.WorkingdirGenerator;
import de.uni_potsdam.hpi.asg.delaymatch.profile.MatchPath;

public class MeasureScriptGenerator {
    private static final Logger logger              = LogManager.getLogger();

    private static final String v_file              = ".v";

    // generated by SimFlow
    private static final String dc_sh_file          = "_measure.sh";
    private static final String dc_tcl_file         = "_measure.tcl";

    // generated by scripts of SimFlow
    private static final String dc_log_file         = "_measure.log";

    // template files
    private static final File   dc_sh_templatefile  = FileHelper.getInstance().getBasedirFile("templates/delay_measure.sh");
    private static final File   dc_tcl_templatefile = FileHelper.getInstance().getBasedirFile("templates/delay_measure.tcl");

    // template code
    private static List<String> setup_code          = null;
    private static List<String> elab_code           = null;
    private static List<String> measure_code        = null;
    private static List<String> final_code          = null;

    private String              name;
    private File                localfile;
    private String              localfolder;

    private Set<DelayMatchPlan> modules;

    public static MeasureScriptGenerator create(File arg_origfile, Set<DelayMatchPlan> modules) {
        if(!readTemplateCodeSnippets()) {
            return null;
        }
        return new MeasureScriptGenerator(arg_origfile, modules);
    }

    private MeasureScriptGenerator(File arg_origfile, Set<DelayMatchPlan> modules) {
        this.modules = modules;
        localfolder = WorkingdirGenerator.getInstance().getWorkingdir();
        localfile = new File(localfolder + arg_origfile);
        name = localfile.getName().split("\\.")[0];
    }

    private static boolean readTemplateCodeSnippets() {
        if(setup_code == null) {
            List<String> current = null;
            setup_code = new ArrayList<>();
            elab_code = new ArrayList<>();
            measure_code = new ArrayList<>();
            final_code = new ArrayList<>();
            List<String> lines = FileHelper.getInstance().readFile(dc_tcl_templatefile);
            for(String line : lines) {
                switch(line) {
                    case "#+setup_begin+#":
                        if(current != null) {
                            logger.error("Found begin before end: setup");
                            return false;
                        }
                        current = setup_code;
                        break;
                    case "#+setup_end+#":
                        current = null;
                        break;
                    case "#+elab_begin+#":
                        if(current != null) {
                            logger.error("Found begin before end: elab");
                            return false;
                        }
                        current = elab_code;
                        break;
                    case "#+elab_end+#":
                        current = null;
                        break;
                    case "#+measure_begin+#":
                        if(current != null) {
                            logger.error("Found begin before end: measure");
                            return false;
                        }
                        current = measure_code;
                        break;
                    case "#+measure_end+#":
                        current = null;
                        break;
                    case "#+final_begin+#":
                        if(current != null) {
                            logger.error("Found begin before end: final");
                            return false;
                        }
                        current = final_code;
                        break;
                    case "#+final_end+#":
                        current = null;
                        break;
                    default:
                        if(current != null) {
                            current.add(line);
                        }
                }
            }
        }
        return true;
    }

    public boolean generate() {

        String rmdcshfile = name + dc_sh_file;
        String dcshfile = localfolder + rmdcshfile;
        FileHelper.getInstance().copyfile(dc_sh_templatefile, new File(dcshfile));
        replaceInSh(localfolder + name + dc_sh_file);

        String dctclfile = localfolder + name + dc_tcl_file;
        List<String> tclfilecontent = new ArrayList<>();
        tclfilecontent.addAll(generateSetupTcl());
        for(DelayMatchPlan plan : modules) {
            tclfilecontent.addAll(generateElabTcl(plan.getName()));
            for(MatchPath path : plan.getProfilecomp().getMatchpaths()) {
                if(path.getForeach() != null) {
//                    plan.getVariables().get(path.getMatch()).getCount();
                }
            }
        }
        System.out.println(tclfilecontent);

        return true;
    }

    private void replaceInSh(String filename) {
        try {
            File f = new File(filename);
            List<String> out = new ArrayList<String>();
            BufferedReader reader = new BufferedReader(new FileReader(f));
            String line = null;
            while((line = reader.readLine()) != null) {
                line = line.replace("#*dc_tcl*#", name + dc_tcl_file);
                out.add(line);
            }
            reader.close();
            FileHelper.getInstance().writeFile(new File(filename), out);
        } catch(IOException e) {
            e.printStackTrace();
        }
    }

    private List<String> generateSetupTcl() {
        List<String> newlines = new ArrayList<>();
        for(String line : setup_code) {
            line = line.replace("#*orig*#", name + v_file);
            line = line.replace("#*dc_log*#", name + dc_log_file);
            newlines.add(line);
        }
        return newlines;
    }

    private List<String> generateElabTcl(String component) {
        List<String> newlines = new ArrayList<>();
        for(String line : elab_code) {
            line = line.replace("#*dc_sub_log*#", name + "_" + component + dc_log_file);
            line = line.replace("#*root_sub*#", component);
            newlines.add(line);
        }
        return newlines;
    }

    private List<String> generateMeasureTcl(String component, String from, String to) {
        List<String> newlines = new ArrayList<>();
        for(String line : measure_code) {
            line = line.replace("#*dc_sub_log*#", name + "_" + component + dc_log_file);
            line = line.replace("#*from_sub*#", from);
            line = line.replace("#*to_sub*#", to);
            newlines.add(line);
        }
        return newlines;
    }
}
