package de.uni_potsdam.hpi.asg.delaymatch.match;

/*
 * Copyright (C) 2016 - 2017 Norman Kluge
 * 
 * This file is part of ASGdelaymatch.
 * 
 * ASGdelaymatch is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * ASGdelaymatch is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ASGdelaymatch.  If not, see <http://www.gnu.org/licenses/>.
 */

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.uni_potsdam.hpi.asg.common.iohelper.BasedirHelper;
import de.uni_potsdam.hpi.asg.common.iohelper.FileHelper;
import de.uni_potsdam.hpi.asg.common.iohelper.WorkingdirGenerator;
import de.uni_potsdam.hpi.asg.common.technology.Technology;
import de.uni_potsdam.hpi.asg.delaymatch.helper.AbstractScriptGenerator;
import de.uni_potsdam.hpi.asg.delaymatch.helper.PortHelper;
import de.uni_potsdam.hpi.asg.delaymatch.model.DelayMatchModule;
import de.uni_potsdam.hpi.asg.delaymatch.profile.MatchPath;
import de.uni_potsdam.hpi.asg.delaymatch.verilogparser.model.VerilogSignalGroup;

public class MatchScriptGenerator extends AbstractScriptGenerator {
    private static final Logger              logger              = LogManager.getLogger();

    private static final String              in_v_file           = "_match_in.v";

    // generated by SimFlow
    private static final String              dc_sh_file          = "_match.sh";
    private static final String              dc_tcl_file         = "_match.tcl";

    // generated by scripts of SimFlow
    private static final String              dc_log_file         = "_match.log";
    private static final String              dc_out_file         = "_match.v";
    private static final String              dc_sdf_file         = "_match.sdf";

    // template files
    private static final File                dc_sh_templatefile  = BasedirHelper.getFileInBasedir("templates/delay_match.sh");
    private static final File                dc_tcl_templatefile = BasedirHelper.getFileInBasedir("templates/delay_match.tcl");

    public static final Pattern              module_pattern      = Pattern.compile("module (.*) \\(.*");

    private static Map<String, List<String>> templates;

    private int                              turnid;
    private String                           name;
    private String                           localfolder;
    private String                           root;
    private Technology                       tech;

    private Map<String, DelayMatchModule>    modules;

    public static MatchScriptGenerator create(int turnid, String name, File arg_origfile, Map<String, DelayMatchModule> modules, Technology tech) {
        if(templates == null) {
            templates = readTemplateCodeSnippets(dc_tcl_templatefile, new String[]{"setup", "elab", "setdelay", "settouch", "compile", "final"});
            if(templates == null) {
                return null;
            }
        }

        if(!FileHelper.getInstance().copyfile(arg_origfile, turnid + "_" + name + in_v_file)) {
            return null;
        }

        String root = getRoot(arg_origfile);

        return new MatchScriptGenerator(turnid, name, root, modules, tech);
    }

    private MatchScriptGenerator(int turnid, String name, String root, Map<String, DelayMatchModule> modules, Technology tech) {
        this.turnid = turnid;
        this.modules = modules;
        this.tech = tech;
        this.name = name;
        this.root = root;
        localfolder = WorkingdirGenerator.getInstance().getWorkingdir();
    }

    public boolean generate() {
        String rmdcshfile = turnid + "_" + name + dc_sh_file;
        String dcshfile = localfolder + rmdcshfile;
        FileHelper.getInstance().copyfile(dc_sh_templatefile, new File(dcshfile));
        replaceInSh(localfolder + turnid + "_" + name + dc_sh_file);

        String dctclfile = localfolder + turnid + "_" + name + dc_tcl_file;
        List<String> tclfilecontent = new ArrayList<>();
        tclfilecontent.addAll(generateSetupTcl());

        for(DelayMatchModule mod : modules.values()) {
            if(mod.getProfilecomp() != null) {
                List<String> moduleTcl = new ArrayList<>();
                moduleTcl.addAll(generateElabTcl(mod.getModuleName()));
                for(MatchPath path : mod.getProfilecomp().getMatchpaths()) {
                    if(path.getForeach() != null) {
                        VerilogSignalGroup group = mod.getSignalGroups().get(path.getForeach());
                        if(group == null) {
                            logger.error("Signal must be group signal!");
                            return false;
                        }
                        int num = group.getCount();
                        for(int eachid = 0; eachid < num; eachid++) {
                            Float min = mod.getControlMinVal(path, eachid);
                            Float max = mod.getControlMaxVal(path, eachid);
                            if(min != null && max != null) {
                                moduleTcl.addAll(generateMatch(mod, path, eachid, min, max));
                            }
                            moduleTcl.addAll(generateDontTouch(mod, path, eachid));
                        }
                    } else {
                        Float min = mod.getControlMinVal(path);
                        Float max = mod.getControlMaxVal(path);
                        if(min != null && max != null) {
                            moduleTcl.addAll(generateMatch(mod, path, null, min, max));
                        }
                        moduleTcl.addAll(generateDontTouch(mod, path, null));
                    }
                }
                moduleTcl.addAll(generatCompileTcl(mod.getModuleName()));
                tclfilecontent.addAll(moduleTcl);
            }
        }
        tclfilecontent.addAll(generateFinalTcl());

        if(!FileHelper.getInstance().writeFile(new File(dctclfile), tclfilecontent)) {
            return false;
        }

        return true;
    }

    private List<String> generateMatch(DelayMatchModule plan, MatchPath path, Integer eachid, Float min, Float max) {
        String from = PortHelper.getPortListAsDCString(path.getMatch().getFrom(), eachid, plan.getSignals());
        String to = PortHelper.getPortListAsDCString(path.getMatch().getTo(), eachid, plan.getSignals());
        logger.info("Setting " + plan.getModuleName() + " " + from + "->" + to + ": min=" + min + ", max=" + max);
        return generateSetDelayTcl(plan.getModuleName(), from, to, min, max);
    }

    private List<String> generateDontTouch(DelayMatchModule plan, MatchPath path, Integer eachid) {
        String touch = PortHelper.getPortListAsDCString(path.getMeasure().getFrom(), eachid, plan.getSignals());
        return generatSetTouchTcl(plan.getModuleName(), touch);
    }

    private void replaceInSh(String filename) {
        try {
            File f = new File(filename);
            List<String> out = new ArrayList<String>();
            BufferedReader reader = new BufferedReader(new FileReader(f));
            String line = null;
            while((line = reader.readLine()) != null) {
                line = line.replace("#*dc_tcl*#", turnid + "_" + name + dc_tcl_file);
                out.add(line);
            }
            reader.close();
            FileHelper.getInstance().writeFile(new File(filename), out);
        } catch(IOException e) {
            e.printStackTrace();
        }
    }

    private List<String> generateSetupTcl() {
        if(!templates.containsKey("setup")) {
            logger.error("Setup template code not found");
            return null;
        }
        List<String> newlines = new ArrayList<>();
        for(String line : templates.get("setup")) {
            line = line.replace("#*orig*#", turnid + "_" + name + in_v_file);
            line = line.replace("#*dc_log*#", turnid + "_" + name + dc_log_file);
            line = line.replace("#*root*#", root);
            line = line.replace("#*search_path*#", tech.getSynctool().getSearchPaths());
            line = line.replace("#*libraries*#", tech.getSynctool().getLibraries());
            newlines.add(line);
        }
        return newlines;
    }

    private List<String> generateElabTcl(String component) {
        if(!templates.containsKey("elab")) {
            logger.error("Elab template code not found");
            return null;
        }
        List<String> newlines = new ArrayList<>();
        for(String line : templates.get("elab")) {
            line = line.replace("#*dc_sub_log*#", turnid + "_" + name + "_" + component + dc_log_file);
            line = line.replace("#*root_sub*#", component);
            newlines.add(line);
        }
        return newlines;
    }

    private List<String> generateSetDelayTcl(String component, String from, String to, Float min, Float max) {
        if(!templates.containsKey("setdelay")) {
            logger.error("Setdelay template code not found");
            return null;
        }
        List<String> newlines = new ArrayList<>();
        for(String line : templates.get("setdelay")) {
            line = line.replace("#*dc_sub_log*#", turnid + "_" + name + "_" + component + dc_log_file);
            line = line.replace("#*root_sub*#", component);
            line = line.replace("#*from_sub*#", from);
            line = line.replace("#*to_sub*#", to);
            line = line.replace("#*time_min_sub*#", min.toString());
            line = line.replace("#*time_max_sub*#", max.toString());
            newlines.add(line);
        }
        return newlines;
    }

    private List<String> generatSetTouchTcl(String component, String touch) {
        if(!templates.containsKey("settouch")) {
            logger.error("Settouch template code not found");
            return null;
        }
        List<String> newlines = new ArrayList<>();
        for(String line : templates.get("settouch")) {
            line = line.replace("#*dc_sub_log*#", turnid + "_" + name + "_" + component + dc_log_file);
            line = line.replace("#*root_sub*#", component);
            line = line.replace("#*touch_sub*#", touch);
            newlines.add(line);
        }
        return newlines;
    }

    private List<String> generatCompileTcl(String component) {
        if(!templates.containsKey("compile")) {
            logger.error("Compile template code not found");
            return null;
        }
        List<String> newlines = new ArrayList<>();
        for(String line : templates.get("compile")) {
            line = line.replace("#*dc_sub_log*#", turnid + "_" + name + "_" + component + dc_log_file);
            line = line.replace("#*root_sub*#", component);
            newlines.add(line);
        }
        return newlines;
    }

    private List<String> generateFinalTcl() {
        if(!templates.containsKey("final")) {
            logger.error("Final template code not found");
            return null;
        }
        List<String> newlines = new ArrayList<>();
        for(String line : templates.get("final")) {
            line = line.replace("#*dc_log*#", turnid + "_" + name + dc_log_file);
            line = line.replace("#*outfile*#", turnid + "_" + name + dc_out_file);
            line = line.replace("#*root*#", root);
            line = line.replace("#*out_sdf*#", turnid + "_" + name + dc_sdf_file);
            newlines.add(line);
        }
        return newlines;
    }

    private static String getRoot(File f) {
        String root = null;
        try {
            BufferedReader reader = new BufferedReader(new FileReader(f));
            String line = null;
            Matcher matcher = null;
            while((line = reader.readLine()) != null) {
                matcher = module_pattern.matcher(line);
                if(matcher.matches()) {
                    root = matcher.group(1);
                }
            }
            reader.close();
        } catch(IOException e) {
            System.out.println(e.getMessage());
            return null;
        }
        return root;
    }

    public Set<String> getScriptFiles() {
        Set<String> retVal = new HashSet<>();
        retVal.add(localfolder + turnid + "_" + name + dc_sh_file);
        retVal.add(localfolder + turnid + "_" + name + dc_tcl_file);
        return retVal;
    }

    public String getExec() {
        return turnid + "_" + name + dc_sh_file;
    }

    public String getOutfile() {
        return turnid + "_" + name + dc_out_file;
    }

    public String getOutSdffile() {
        return turnid + "_" + name + dc_sdf_file;
    }

    public String getVInFile() {
        return localfolder + turnid + "_" + name + in_v_file;
    }
}
